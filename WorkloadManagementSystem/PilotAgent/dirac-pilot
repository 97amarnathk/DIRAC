#!/usr/bin/env python
########################################################################
# $Header: /tmp/libdirac/tmp.stZoy15380/dirac/DIRAC3/DIRAC/WorkloadManagementSystem/PilotAgent/dirac-pilot,v 1.63 2009/10/21 08:07:26 rgracian Exp $
# File :   dirac-pilot
# Author : Ricardo Graciani
########################################################################
"""
 Perform initial sanity checks on WN, installs and configures DIRAC and runs
 Job Agent to execute pending workload on WMS.
 It requires dirac-install script to be sitting in the same directory.
"""
__RCSID__ = "$Id: dirac-pilot,v 1.63 2009/10/21 08:07:26 rgracian Exp $"
try:
  import os
  import sys

  os.umask(022)

  pythonpath = os.getenv('PYTHONPATH','').split(':')
  newpythonpath = []
  for p in pythonpath:
      if p == '': continue
      try:
        if os.path.normpath(p) in sys.path:
          # In case a given directory is twice in PYTHONPATH it has to removed only once
          sys.path.remove(os.path.normpath(p))
      except Exception, x:
        print 'Directories in PYTHONPATH:', pythonpath
        print 'Failing path:', p, os.path.normpath(p)
        print 'sys.path:', sys.path
        raise x

  os.environ['PYTHONPATH'] = ''

  import os, sys, socket, re, stat, popen2, time

  debugFlag = False
  localFlag = False
  testFlag  = False
  testVOMSOK = False
  defaultSite = 'LCG.CERN.ch'
  localPlatform = False
  minDiskSpace  = 2560 # MB
  jobCPUReqt    = 900  # s
  diracGroup    = None
  ownerDN       = None

  MAX_CYCLES    = 5
  maxCycles     = 1

  installScript = 'dirac-install'
  csCache = 'dirac-configuration-dump-local-cache'

  try:
    myFullName  = os.path.realpath( __file__ )
    # in old python versions __file__ is not defined
  except:
    myFullName  = os.path.realpath( sys.argv[0] )
  myShortName = os.path.basename( myFullName )
  myPath      = os.path.dirname( myFullName )
  myFlavour   = 'DIRAC'
  rootPath    = os.getcwd()
except Exception, x:
  print sys.executable
  print sys.version
  print os.uname()
  print x
  raise x

installScript = os.path.join( myPath, installScript )

if not os.path.exists( installScript ):
  print '"%s" requires "%s" in the same directory'
  sys.exit(0)
os.chmod( installScript, stat.S_IRWXU )

def parse_options():
  """
   parse command line options:
  """
  import getopt
  global debugFlag, rootPath, localPlatform, minDiskSpace, testFlag, jobCPUReqt, diracGroup, ownerDN, maxCycles, lcgVer
  help = """
   -b --build                  Force local compilation
   -d --debug                  Set debug flag
   -e --external=<version>     DIRAC-external <version> to install (overwrites -v)
   -g --grid=<version>         lcg tools package version
   -h --help                   Print this
   -i --python=<24|25>         Use python<24|25> interpreter
   -n --name=<Site>            Set <Site> as Site Name
   -p --platform=<platform>    Use <platform> instead of local one
   -r --repository=<rep>       Use <rep> as cvs repository
   -t --test                   Install test, do not run JobAgent
   -u --url=<url>              Use <url> to download tarballs
   -v --version=<version>      DIRAC <version> to install
   -C --cvs                    Retrieve from CVS (implies -b)
   -D --disk=<space>           Require at least <space> MB available
   -M --MaxCycles=<n>          Maximum Number of JobAgent cycles to run
   -N --Name=<CEName>          Use <CEName> to determine Site Name
   -P --path=<root>            Install under <root>
   -S --server                 Make a full server installation
   -T --CPUTime=<Time>         Requested CPU Time
   -G --Group=<group>          DIRAC group to be setup
   -O --OwnerDN=<ownerDN>      Pilot OwnerDN (for private pilots)
   -U --Upload                 Upload compiled distribution to lhcbweb (if -b)
   -V --VO=                    Virtual Organization (default = lhcb)
   -W --gateway=<gateway>      Configure <gateway> as DIRAC Gateway during installation

  from DIRAC framework:

    -o --option=<Option=value> <Option=value> to add
    -s --section=<section>     Set base <section> for relative parsed options
    -c --cert=<cert>           Use server certificate <cert> to connect to Core Services

  """
  shortOptions = 'bde:g:hi:n:p:r:tu:v:o:s:CM:N:D:P:ST:G:O:UV:W:'
  longOptions  = ['build', 'debug', 'external=', 'grid=','help', 'python=', 'name=',
                  'platform=', 'repository', 'test', 'url=', 'version=',
                  'cvs', 'MaxCycles=', 'Name=', 'disk=', 'path=', 'server', 'CPUTime=', 'Group=',
                  'OwnerDN=','Upload', 'VO=', 'gateway',
                  'option=', 'section=', 'cert=']
  try:
    ( optionVals, extraOptions ) = getopt.getopt( sys.argv[1:], shortOptions, longOptions )
  except getopt.GetoptError, x:
    print 'ERROR Parsing command line: %s' % x
    optionVals = [ ('-h','') ]

  if ('-h','') in optionVals or ('--help','') in optionVals:
    print
    print 'Usage: %s [options]' % myShortName
    print help
    sys.exit(0)

  installOpts = []

  for o,v in optionVals:
    if o == '-b' or o == '--build':
      installOpts.append('-b')
    elif o == '-d' or o == '--debug':
      debugFlag = True
      installOpts.append('-d')
    elif o == '-e' or o == '--external':
      installOpts.append('-e')
      installOpts.append(v)
    elif o == '-g' or o == '--grid':
      installOpts.append('-g')
      installOpts.append(v)
    elif o == '-i' or o == '--python':
      installOpts.append('-i')
      installOpts.append(v)
    elif o == '-n' or o == '--name':
      installOpts.append('-n')
      installOpts.append(v)
      defaultSite = v
    elif o == '-p' or o == '--platform':
      installOpts.append('-p')
      installOpts.append(v)
      localPlatform = v
    elif o == '-r' or o == '--repository':
      installOpts.append('-r')
      installOpts.append(v)
    elif o == '-t' or o == '--test':
      testFlag = True
    elif o == '-u' or o == '--url':
      installOpts.append('-u')
      installOpts.append(v)
    elif o == '-v' or o == '--version':
      installOpts.append('-v')
      installOpts.append(v)
    elif o == '-C' or o == '--cvs':
      installOpts.append('-C')
    elif o == '-N' or o == '--Name':
      installOpts.append('-N')
      installOpts.append(v)
    elif o == '-D' or o == '--disk':
      minDiskSpace = int(v)
    elif o == '-M' or o == '--MaxCycles':
      try:
        maxCycles = int(v)
      except:
        pass
      maxCycles = min(MAX_CYCLES, maxCycles)
    elif o in ('-P', '--path'):
      rootPath = v
      installOpts.append('-P')
      installOpts.append(v)
    elif o in ('-T', '--CPUTime'):
      jobCPUReqt = v
    elif o in ('-G', '--Group'):
      diracGroup = v
    elif o in ('-O', '--OwnerDN'):
      ownerDN = v
    elif o in ('-U', '--Upload'):
      installOpts.append('-U')
    elif o in ('-V', '--VO' ):
      installOpts.append('-V')
      installOpts.append("'%s'" % v )
    elif o in ('-W', '--gateway' ):
      installOpts.append('-W')
      installOpts.append("'%s'" % v )
    elif o == '-S' or o == '--server':
      installOpts.append('-S')
      installOpts.append(v)
    elif o == '-o' or o == '--option':
      installOpts.append('-o')
      installOpts.append(v)
    elif o == '-s' or o == '--section':
      installOpts.append('-s')
      installOpts.append(v)
    elif o == '-c' or o == '--cert':
      installOpts.append('-c')
      installOpts.append(v)

  return str.join( ' ', installOpts )

def createDir( dir ):
  """
   Atempt to create directory
  """
  if not os.path.exists( dir ):
    try:
      os.makedirs( dir )
    except Exception,x:
      logERROR( 'Could not create directory %s' % dir )
      sys.exit(0)


pilotRef = 'Unknown'
if os.environ.has_key('EDG_WL_JOBID'):
  myFlavour = 'LCG'
  pilotRef=os.environ['EDG_WL_JOBID']

if os.environ.has_key('GLITE_WMS_JOBID'):
  myFlavour = 'gLite'
  pilotRef = os.environ['GLITE_WMS_JOBID']

installOpts = ' -o /LocalSite/GridMiddleware=%s ' % myFlavour

installOpts+= parse_options()

if pilotRef != 'Unknown':
  (child_stdout, child_stdin, child_stderr) = popen2.popen3( 'edg-brokerinfo getCE || glite-brokerinfo getCE' )
  CE = child_stdout.read().strip()
  LCG_SITE_CE = CE.split(':')[0]
  child_stdout.close()
  child_stderr.close()
  installOpts += ' -o /LocalSite/PilotReference=%s' % pilotRef
  installOpts += ' -N "%s"' % LCG_SITE_CE
else:
  LCG_SITE_CE = 'Local'

if localPlatform:
  installOpts += ' -p %s' % localPlatform

if diracGroup:
  installOpts+= ' -o /AgentJobRequirements/OwnerGroup="%s"' % diracGroup

if ownerDN:
  installOpts+= ' -o /AgentJobRequirements/OwnerDN="%s"' % ownerDN
  

cmd = '%s %s' % ( installScript,  installOpts )

if debugFlag:
  print 'DEBUG Executing: %s' % cmd
  sys.stdout.flush()
ret = os.system( cmd )

if ret != 0:
  print ret
  if ret == 256:
    # The platfrom is not available, try to build it
    installOpts += ' -U'
    cmd = '%s %s' % ( installScript,  installOpts )
    if debugFlag:
      print 'DEBUG Executing: %s' % cmd
      sys.stdout.flush()
    ret = os.system( cmd )
    if ret != 0:
      print
      print 'ERROR could not make a proper DIRAC installation'
      print
      sys.exit(0)
  elif ret == 512:
    # The dirac-install script was out of date, now it has been updated
    # run again
    print 'DEBUG Executing again: %s' % cmd
    ret = os.system( cmd )
    if ret != 0:
      print
      print 'ERROR could not make a proper DIRAC installation'
      print
      sys.exit(0)
  else:
    print
    print 'ERROR could not make a proper DIRAC installation'
    print
    sys.exit(0)

# Add the scripts directory to the Python search path to import from it
myPath     = os.path.join( rootPath, 'scripts' )
myFullName = os.path.join( myPath, myShortName )
sys.path.insert( 0, myPath )
os.environ['PATH'] = '%s:%s' % (myPath,os.getenv('PATH'))
cfgFile = os.path.join( rootPath, "etc", "dirac.cfg" )

platformDict = { 'slc4_ia32_gcc34' : 'Linux_i686_glibc-2.3.4',
                 'slc4_amd64_gcc34': 'Linux_x86_64_glibc-2.3.4' }

queueNorm = 0.0

class Dirac:
  def __init__( self, fullName  ):
    """
     Initialize the functions class using the given script path to set the
     rootPath of the DIRAC intallation.
    """
    self.setRoot( fullName )
    self.lhcbPlatform()

  def __log( self, level, msg ):
    """
     Print log entries similar to DIRAC Logger
    """
    logTime = time.strftime('%Y-%m-%d %H:%M:%S',time.gmtime()) + " UTC"
    # logTime = str( datetime.datetime.utcnow( ) ).split('.')[0] + " UTC"
    if level != 'DEBUG ' or self.debugFlag:
      for line in msg.split( '\n' ):
        print logTime, self.shortName, level, line
        sys.stdout.flush()

  def logEXCEP( self, msg ):
    self.__log( 'EXCEPT', str(msg) )
    sys.exit( -1 )

  def logERROR( self, msg ):
    self.__log( 'ERROR ', msg )

  def logINFO( self, msg ):
    self.__log( 'INFO  ', msg )

  def logDEBUG( self, msg ):
    self.__log( 'DEBUG ', msg )

  def logHelp( self, help ):
    print
    print 'Usage: %s [options]' % self.shortName
    print help
    sys.exit(-1)

  def setRoot( self, fullName ):
    if fullName[0] != '/':
      self.logERROR( 'Install path must be absolute.' )
      sys.exit(-1)
    self.shortName   = os.path.basename( fullName )
    self.scriptsPath = os.path.dirname( fullName )
    if os.path.basename( self.scriptsPath ) != 'scripts':
      # We are doing a new installation, add scripts to PATH
       self.scriptsPath = os.path.join( self.scriptsPath, 'scripts' )

    self.__rootPath    = os.path.dirname( self.scriptsPath )
    try:
      os.chdir( self.__rootPath )
    except Exception, x:
      self.logERROR( 'Can not chdir to requested installation Root "%s"' % self.__rootPath )
      self.logEXCEP( x )

  def platform( self, platform=None ):
    """
     Use platform.py script to retrieve the local platform
    """
    # First check that we are in a valid directory and create platform.py in the scripts directory
    self.nativePlatform = self.scriptOutput( 'platform.py' )
    if not platform:
      self.localPlatform = self.nativePlatform
    else:
      if platform in platformDict:
        self.localPlatform = platformDict[platform]
      else:
        self.localPlatform = platform

    if self.localPlatform == 'ERROR' or self.localPlatform == "":
      self.logERROR( 'Can not determine local platform' )
      sys.exit(-1)

    self.installedPython = os.path.join( self.__rootPath,
                           self.localPlatform,
                           'bin', 'python' )

  def lhcbPlatform(self):
    """
      determine local architecture as defined by LHCb
    """
    self.lhcb_platform = self.scriptOutput( 'dirac-architecture' )


  def scriptOutput(self, scriptName, exitOnError=True, interpreter=None):
    """
     Execute a script from the scripts directory and return its output
    """
    diracScript = os.path.join( self.scriptsPath, scriptName )
    if not os.path.exists( diracScript ):
      if exitOnError:
        self.logERROR( 'Missing file %s' % diracScript )
        sys.exit(-1)
      else:
        return ''
    if interpreter:
      (child_stdout, child_stdin) = popen2.popen2( '%s %s' % ( interpreter, diracScript) )
    else:
      (child_stdout, child_stdin) = popen2.popen2( diracScript )
    stdout = child_stdout.read().strip()
    child_stdout.close()
    return stdout

# Check voms-proxy-info before touching the original PATH and LD_LIBRARY_PATH
os.system( 'which voms-proxy-info && voms-proxy-info -all' )
#
os.system( "%s -f %s" % ( csCache, cfgFile ) )
dirac = Dirac( myFullName )
dirac.platform(localPlatform)
myLib = os.path.join( rootPath, dirac.localPlatform, 'lib' )
myBin = os.path.join( rootPath, dirac.localPlatform, 'bin' )
os.environ['LD_LIBRARY_PATH_SAVE'] = os.environ['LD_LIBRARY_PATH']
os.environ['LD_LIBRARY_PATH'] = "%s" % (myLib)
os.environ['PATH'] = '%s:%s' % (myBin,os.getenv('PATH'))

# End of initialisation

# Preamble
dirac.logINFO( 'Starting %s' % __RCSID__ )
ret = os.system('dirac-proxy-info')
if testVOMSOK:
  ret = os.system('dirac-proxy-info | grep -q fqan')
  if ret != 0:
    os.system('dirac-proxy-info 2>&1 | mail -s "dirac-pilot: missing voms certs at %s" dirac.alarms@gmail.com' % LCG_SITE_CE )
    sys.exit(-1)
os.environ['CMTCONFIG'] = dirac.lhcb_platform
dirac.logINFO( 'Setting CMTCONFIG=%s' % dirac.lhcb_platform )

if localFlag:
  os.system('%s -o /LocalSite/Site=%s' % (installScript, defaultSite ) )
  pass
else:
  # Here the site discovery code should go.
  pass

localHost = socket.gethostname()
localUid  = os.getuid()
try:
  import pwd
  localUser = pwd.getpwuid(localUid)[0]
except:
  localUser = 'Unknown'
localUname = os.uname()

dirac.logINFO( str.join(' ', localUname) )
dirac.logINFO( 'Host Name  = %s' % localHost )
dirac.logINFO( 'User Name  = %s' % localUser )
dirac.logINFO( 'User Id    = %s' % localUid )
dirac.logINFO( 'CurrentDir = %s' % rootPath )

fileName = '/etc/redhat-release'
if os.path.exists( fileName ):
  f = open( fileName, 'r' )
  dirac.logINFO( 'RedHat Release = %s' % f.read().strip() )
  f.close()

fileName = '/proc/cpuinfo'
if os.path.exists( fileName ):
  f = open( fileName, 'r' )
  cpu = f.readlines()
  f.close()
  nCPU = 0
  for line in cpu:
    if line.find( 'cpu MHz' ) == 0:
      nCPU += 1
      freq = line.split()[3]
    elif line.find( 'model name' ) == 0:
      CPUmodel = line.split(': ')[1].strip()
  dirac.logINFO( 'CPU (model)    = %s' % CPUmodel )
  dirac.logINFO( 'CPU (MHz)      = %s x %s' % ( nCPU, freq ) )

fileName = '/proc/meminfo'
if os.path.exists( fileName ):
  f = open( fileName, 'r' )
  mem = f.readlines()
  f.close()
  freeMem = 0
  for line in mem:
    if line.find( 'MemTotal:' ) == 0:
      totalMem = int(line.split()[1])
    if line.find( 'MemFree:' ) == 0:
      freeMem += int(line.split()[1])
    if line.find( 'Cached:' ) == 0:
      freeMem += int(line.split()[1])
  dirac.logINFO( 'Memory (kB)    = %s' % totalMem )
  dirac.logINFO( 'FreeMem. (kB)  = %s' % freeMem )


fs = os.statvfs(rootPath)
# bsize;    /* file system block size */
# frsize;   /* fragment size */
# blocks;   /* size of fs in f_frsize units */
# bfree;    /* # free blocks */
# bavail;   /* # free blocks for non-root */
# files;    /* # inodes */
# ffree;    /* # free inodes */
# favail;   /* # free inodes for non-root */
# flag;     /* mount flags */
# namemax;  /* maximum filename length */
diskSpace = fs[4] * fs[0] / 1024 / 1024
dirac.logINFO( 'DiskSpace (MB) = %s' % diskSpace )

if diskSpace < minDiskSpace:
  dirac.logERROR( '%s MB < %s MB, not enough local disk space available, exiting'
                  % (diskSpace, minDiskSpace) )
  sys.exit(0)

if pilotRef != 'Unknown':
  dirac.logINFO( 'CE = %s' % CE )
  dirac.logINFO( 'LCG_SITE_CE = %s' % LCG_SITE_CE )

  (child_stdout, child_stdin, child_stderr) = popen2.popen3( 'dirac-wms-get-queue-normalization %s' % CE )
  queueNormList = child_stdout.read().strip().split(' ')
  if len(queueNormList) == 2:
    queueNorm = float(queueNormList[1])
    dirac.logINFO( 'Queue Normalization = %s SI00' % queueNorm )
    if queueNorm:
      # Update the local normalization factor: We are using seconds @ 500 SI00
      # This is the ratio SpecInt published by the site over 500 (the reference used for Matching)
      os.system( "%s -f %s -o /LocalSite/CPUScalingFactor=%s" % ( csCache, cfgFile, queueNorm / 500. ) )
  else:
    dirac.logERROR( 'Fail to get Normalization of the Queue' )
  child_stdout.close()
  child_stderr.close()

  (child_stdout, child_stdin, child_stderr) = popen2.popen3( 'dirac-wms-get-normalized-queue-length %s' % CE )
  queueLength = child_stdout.read().strip().split(' ')
  if len(queueLength) == 2:
    jobCPUReqt = float(queueLength[1])
    dirac.logINFO( 'Normalized Queue Length = %s' % jobCPUReqt )
  else:
    dirac.logERROR( 'Fail to get Normalized lenght of the Queue' )
  child_stdout.close()
  child_stderr.close()

# further local configuration
inProcessOpts = ' -s /Resources/Computing/CEDefaults'
inProcessOpts+= ' -o WorkingDirectory=%s' % rootPath
inProcessOpts+= ' -o GridCE=%s' % LCG_SITE_CE
inProcessOpts+= ' -o LocalAccountString=%s' % localUser
inProcessOpts+= ' -o TotalCPUs=%s' % 1
inProcessOpts+= ' -o MaxCPUTime=%s' % ( int(jobCPUReqt) )
inProcessOpts+= ' -o CPUTime=%s' % ( int(jobCPUReqt) )
inProcessOpts+= ' -o MaxRunningJobs=%s' % 1
# To prevent a wayward agent picking up and failing many jobs.
inProcessOpts+= ' -o MaxTotalJobs=%s' % 10

# jobAgentControl = os.path.join( rootPath, 'agentFlags', 'JobAgent' )
# createDir( jobAgentControl )

# watchdogControl = os.path.join( rootPath, 'control', 'WorkloadManagement', 'Watchdog' )
# createDir( watchdogControl )

jobAgentOpts = ''
# jobAgentOpts += ' -o CEUniqueID=%s' % JOB_AGENT_CE
# jobAgentOpts += ' -o ControlDirectory=%s' % jobAgentControl
jobAgentOpts+= ' -o MaxCycles=%s' % maxCycles
if debugFlag:
  jobAgentOpts+= ' -o LogLevel=DEBUG'

# watchdogOpts = ' -o ControlDirectory=%s' % watchdogControl
# if debugFlag:
#   watchdogOpts+= ' -o LogLevel=DEBUG'

if diracGroup:
  dirac.logINFO( 'Setting DIRAC Group to "%s"' % diracGroup )
  inProcessOpts       += ' -o OwnerGroup="%s"' % diracGroup

if ownerDN:
  dirac.logINFO( 'Setting Owner DN to "%s"' % ownerDN )
  inProcessOpts       += ' -o OwnerDN="%s"' % ownerDN

# Find any .cfg file uploaded with the sandbox
extraCFG = ''
for i in os.listdir( rootPath ):
  cfg = os.path.join( rootPath, i )
  if os.path.isfile( cfg ) and re.search( '.cfg&', cfg ):
    extraCFG += ' %s' % cfg

dirac.logINFO( 'Starting JobAgent' )

os.environ['PYTHONUNBUFFERED'] = 'yes'

jobAgent = 'dirac-agent WorkloadManagement/JobAgent %s %s %s' % (
            jobAgentOpts, inProcessOpts,  extraCFG )
dirac.logINFO( jobAgent )

if not testFlag:
  os.system( jobAgent )

fs = os.statvfs(rootPath)
# bsize;    /* file system block size */
# frsize;   /* fragment size */
# blocks;   /* size of fs in f_frsize units */
# bfree;    /* # free blocks */
# bavail;   /* # free blocks for non-root */
# files;    /* # inodes */
# ffree;    /* # free inodes */
# favail;   /* # free inodes for non-root */
# flag;     /* mount flags */
# namemax;  /* maximum filename length */
diskSpace = fs[4] * fs[0] / 1024 / 1024
dirac.logINFO( 'DiskSpace (MB) = %s' % diskSpace )
ret = os.system('dirac-proxy-info')

# ls work/*

sys.exit(0)
