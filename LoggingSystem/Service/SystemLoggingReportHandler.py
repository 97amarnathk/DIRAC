# $Header: /tmp/libdirac/tmp.stZoy15380/dirac/DIRAC3/DIRAC/LoggingSystem/Service/SystemLoggingReportHandler.py,v 1.7 2008/09/16 11:24:23 mseco Exp $
__RCSID__ = "$Id: SystemLoggingReportHandler.py,v 1.7 2008/09/16 11:24:23 mseco Exp $"
"""
SystemLoggingReportHandler produce the number that match certain criteria

    The following methods are available in the Service interface

    getMessagesReport()
    getGroups()
    getSites()
    getSystems()
    getSubSystems()
    getFixedTextStrings()
"""
from DIRAC import S_OK, S_ERROR, gConfig, gLogger
from DIRAC.Core.Utilities import Time
from DIRAC.Core.DISET.RequestHandler import RequestHandler
from DIRAC.LoggingSystem.private.Message import tupleToMessage
from DIRAC.LoggingSystem.DB.SystemLoggingDB import SystemLoggingDB

def initializeSystemLoggingReportHandler( serviceInfo ):

  global LogDB
  LogDB = SystemLoggingDB()
  return S_OK()


class SystemLoggingReportHandler( RequestHandler ):

  def __getMessagesReport( self, beginDate=None, endDate=None ):
    return LogDB.getCountMessages( beginDate, endDate )

  def __getSitesReport( self, beginDate=None, endDate=None ):
    retval = LogDB.getSites()
    if not retval['OK']: return retval
    sites = retval['Value']

    siteList = []
    for site in sites:
      retval = LogDB.getCountMessages({'SiteName': site[0]},
                                      beginDate, endDate )
      if not retval['OK']: return retval

      siteList.append( [ site[0], int( retval['Value'] ) ] )

    return S_OK( siteList )

  def __getGroupsReport( self, beginDate=None, endDate=None ):
    retval = LogDB.getGroups()
    if not retval['OK']: return retval
    groups = retval['Value']

    groupList = []
    for group in groups:
      retval = LogDB.getCountMessages( {'OwnerGroup': group[0]},
                                       beginDate, endDate )
      if not retval['OK']: return retval

      groupList.append( [ group[0], int( retval['Value'] ) ] )

    return S_OK( groupList )

  def __getSystemsReport( self, beginDate=None, endDate=None ):
    retval = LogDB.getSystems()
    if not retval['OK']: return retval
    systems=retval['Value']

    systemList=[]
    for system in systems:
      retval = LogDB.getCountMessages( {'SystemName': system[0]},
                                       beginDate, endDate )
      if not retval['OK']: return retval

      systemList.append( [ system[0], int( retval['Value'] ) ] )

    return S_OK( systemList )

  def __getSubSystemsReport( self, beginDate=None, endDate=None ):
    retval = LogDB.getSubSystems()
    if not retval['OK']: return retval
    subSystems = retval['Value']

    subSystemList = []
    for subSystem in subSystems:
      retval = LogDB.getCountMessages( {'SubSystemName': subSystem[0]},
                                       beginDate, endDate )
      if not retval['OK']: return retval

      subSystemList.append( [ subSystem[0], int( retval['Value'] ) ] )

    return S_OK( subSystemList )

  def __getFixedTextStringsReport( self, beginDate=None, endDate=None ):
    retval = LogDB.getFixedTextStrings()
    if not retval['OK']: return retval
    fixedTextStrings=retval['Value']

    fixedTextStringList=[]
    for fixedTextString in fixedTextStrings:
      retval = LogDB.getCountMessages( {'FixedTextString': fixedTextString[0]},
                                       beginDate, endDate )
      if not retval['OK']: return retval

      fixedTextStringList.append( [ fixedTextString[0],
                                    int( retval['Value'] ) ] )

    return S_OK( fixedTextStringList )
  
  def __getTopErrorsReport( self, beginDate=None, endDate=None,
                            records=None ):
    fieldList = [ 'SystemName', 'SubSystemName', 'FixedTextString' ]
    retval = LogDB.getGroupedMessages( fieldList, {}, 'FixedTextString',
                                       beginDate, endDate )
    if not retval['OK']: return retval

    tmpOrderedFields=[ ( s[3], s ) for s in retval['Value'] ]
    tmpOrderedFields.sort()
    orderedFields = [ t[1] for t in tmpOrderedFields ]
    orderedFields.reverse()
    
    if records:
      return S_OK( orderedFields[ :records ] )
    else:
      return S_OK( orderedFields )
    
  #A normal exported function (begins with export_)

  types_getMessagesReport = []

  def export_getMessagesReport( self, beginDate=None, endDate=None ):
    """ returns the total number of messages generated between
        beginDate and endDate
    """
    return self.__getMessagesReport( beginDate, endDate )
    
  types_getSitesReport = []

  def export_getSitesReport( self, beginDate=None, endDate=None ):
    """ returns the number of messages generated by each site
        between beginDate and endDate 
    """
    return self.__getSitesReport( beginDate, endDate )

  types_getGroupsReport = []

  def export_getGroupsReport( self, beginDate=None, endDate=None ):
    """ reports the number of messages generated by each group
        between beginDate and endDate 
    """
    return self.__getGroupsReport( beginDate, endDate )

  types_getSystemsReport = []

  def export_getSystemsReport( self, beginDate=None, endDate=None ):
    """ reports the number of messages generated by each group
        between beginDate and endDate 
    """ 
    return self.__getSystemsReport( beginDate, endDate )

  types_getSubSystemsReport = []

  def export_getSubSystemsReport( self, beginDate=None, endDate=None ):
    """ reports the number of messages generated by each group
        between beginDate and endDate 
    """ 
    return self.__getSubSystemsReport( beginDate, endDate )

  types_getFixedTextStringsReport = []

  def export_getFixedTextStringsReport( self, beginDate=None, endDate=None ):
    """ reports the number of messages generated by each group
        between beginDate and endDate 
    """ 
    return self.__getFixedTextStringsReport( beginDate, endDate )

  types_getTopErrorsReport = []

  def export_getTopErrorsReport( self, beginDate=None, endDate=None,
                                 records=None ):
    """ reports the number of messages per fixed text string and
        the system and subsystem that generated them.
    """
    return self.__getTopErrorsReport( beginDate, endDate, records )

  types_getTopErrorsForWebPage = []
  
  def export_getTopErrorsForWebPage(self, selectionDict = {}, sortList = [], 
                                    startItem = 0, maxItems = 0):
    """  This function reports the number of messages per fixed text
         string, system and subsystem that generated them using the 
         DIRAC convention for communications between services and 
         web pages
    """
    condDict={}
    fieldList = [ 'SystemName', 'SubSystemName', 'FixedTextString' ]
    if selectionDict.has_key( 'SystemName' ) and selectionDict['SystemName']:
      condDict['SystemName']=selectionDict['SystemName']
    if selectionDict.has_key( 'FixedTextString' ) and selectionDict['FixedTextString']:
      condDict['FixedTextString']=selectionDict['FixedTextString']
    if selectionDict.has_key( 'SiteName' ) and selectionDict['SiteName']:
      fieldList.append( 'SiteName' )
      condDict['SiteName']=selectionDict['SiteName']

    if selectionDict.has_key( 'beginDate' ):
      beginDate=selectionDict['beginDate']
    else:
      beginDate=None
    if selectionDict.has_key( 'endDate' ):
      endDate=selectionDict['endDate']
    else:
      endDate=None
      
    result = LogDB.getGroupedMessages( fieldList, condDict, 'FixedTextString',
                                       sortList, beginDate, endDate )

    if not result['OK']: return result

    if maxItems:
      records = result['Value'][ startItem:maxItems + startItem ]
    else:
      records = result['Value'][ startItem: ]

    if not sortList:
      unOrderedFields = [ ( s[-1], s ) for s in records ]
      unOrderedFields.sort()
      records = [ t[1] for t in unOrderedFields ]
      records.reverse()

    if 'count(*) as recordCount' in fieldList:
      fieldList.remove( 'count(*) as recordCount' )
    fieldList.append( 'Number of Errors' )

    retValue={ 'ParameterNames': fieldList, 'Records': records ,
           'TotalRecords': len( records ), 'Extras': {}}
    
    return S_OK( retValue )